// Generated by CoffeeScript 1.12.7
var assertType, fs, getMapPath, green, path, printError, red, ref;

assertType = require("assertType");

path = require("path");

fs = require("fsx");

ref = log.color, red = ref.red, green = ref.green;

module.exports = function(coffee) {
  var transformFile, transformFiles;
  transformFile = function(file, options) {
    var config, dest, input, lastModified, mapPath, output;
    lastModified = Date.now();
    file.invalidate();
    input = file.read();
    if (!options.quiet) {
      log.it("Transforming: " + (green(path.relative(path.dirname(file.module.path), file.path))));
    }
    config = {
      bare: options.bare,
      header: true,
      filename: file.path
    };
    if (options.sourceMap) {
      mapPath = getMapPath(file);
      config.sourceMap = true;
      config.sourceRoot = path.relative(path.dirname(mapPath), path.dirname(file.path));
      config.sourceFiles = [file.name + ".coffee"];
      config.generatedFile = file.name + ".js";
    }
    output = coffee.compile(input, config);
    if (options.sourceMap) {
      file.mapDest = mapPath;
      fs.writeDir(path.dirname(mapPath));
      fs.writeFile(mapPath, output.v3SourceMap);
      output = [output.js, "\n", path.relative(path.dirname(file.dest), mapPath), "\n"].join("");
    }
    fs.writeDir(path.dirname(file.dest));
    fs.writeFile(file.dest, output);
    dest = lotus.File(file.dest, file.module);
    dest.lastModified = lastModified;
    return dest;
  };
  transformFiles = function(files, options) {
    var error, errors, file, i, len;
    errors = [];
    for (i = 0, len = files.length; i < len; i++) {
      file = files[i];
      assertType(file, lotus.File);
      if (file.extension === ".coffee") {
        try {
          transformFile(file, options);
        } catch (error1) {
          error = error1;
          error.filePath = file.path;
          errors.push(error);
        }
      }
    }
    return errors;
  };
  return function(files, options) {
    var error, errors, file;
    if (options == null) {
      options = {};
    }
    assertType(options, Object);
    if (options.bare == null) {
      options.bare = true;
    }
    if (options.sourceMap == null) {
      options.sourceMap = false;
    }
    if (Array.isArray(files)) {
      errors = transformFiles(files, options);
      if (errors.length && !options.quiet) {
        errors.forEach(printError);
      }
      return errors;
    }
    assertType(file = files, lotus.File);
    if (file.extension === ".coffee") {
      try {
        return transformFile(file, options);
      } catch (error1) {
        error = error1;
        error.filePath = file.path;
        if (!options.quiet) {
          printError(error);
        }
        return error;
      }
    }
  };
};

getMapPath = function(file) {
  var inputDir, outputDir;
  inputDir = path.join(file.module.path, file.dir);
  outputDir = path.join(file.module.dest, path.relative(file.module.src, inputDir));
  return path.join(outputDir, "map", file.name + ".map");
};

printError = function(error) {
  log.it("Failed to compile: " + (red(error.filePath)));
  log.gray.dim(error.codeFrame || error.stack);
  return log.moat(1);
};
