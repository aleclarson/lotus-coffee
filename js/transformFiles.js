// Generated by CoffeeScript 1.12.4
var assertType, coffee, fs, path, printSyntaxError, red, transformFile;

printSyntaxError = require("printSyntaxError");

assertType = require("assertType");

coffee = require("coffee-script");

path = require("path");

fs = require("fsx");

red = log.color.red;

module.exports = function(files, options) {
  var error, failed, file, i, j, len, len1, makePromise, ref, transformed;
  if (options == null) {
    options = {};
  }
  assertType(files, Array);
  assertType(options, Object);
  if (options.maps == null) {
    options.maps = false;
  }
  if (options.bare == null) {
    options.bare = true;
  }
  makePromise = options.serial ? Promise.chain : Promise.all;
  transformed = [];
  failed = [];
  for (i = 0, len = files.length; i < len; i++) {
    file = files[i];
    try {
      file = transformFile(file, options);
      transformed.push(file);
    } catch (error1) {
      error = error1;
      failed.push({
        file: file,
        error: error
      });
    }
  }
  if (failed.length && !options.quiet) {
    for (j = 0, len1 = failed.length; j < len1; j++) {
      ref = failed[j], file = ref.file, error = ref.error;
      log.it("Failed to compile: " + (red(file.path)));
      log.gray.dim(error.codeFrame || error.stack);
      log.moat(1);
    }
  }
  return transformed;
};

transformFile = function(file, options) {
  var code, dest, destDir, error, generatedFile, green, js, lastModified, mapPath, sourceDir, sourceFiles, sourceRoot, transformed;
  assertType(file, lotus.File);
  if (!file.dest) {
    log.it("File must have 'dest' defined before compiling: " + (red(file.path)));
    return;
  }
  lastModified = new Date;
  if (options.maps) {
    sourceDir = path.join(file.module.path, file.dir);
    destDir = path.join(file.module.dest, path.relative(file.module.src, sourceDir));
    mapPath = path.join(destDir, "map", file.name + ".map");
    sourceRoot = path.relative(path.dirname(mapPath), path.dirname(file.path));
    sourceFiles = [file.name + ".coffee"];
    generatedFile = file.name + ".js";
  }
  file.invalidate();
  code = file.read();
  if (!options.quiet) {
    green = log.color.green;
    log.it("Transforming: " + (green(path.relative(path.dirname(file.module.path), file.path))));
  }
  try {
    transformed = coffee.compile(code, {
      filename: file.path,
      sourceRoot: sourceRoot,
      sourceFiles: sourceFiles,
      generatedFile: generatedFile,
      sourceMap: options.maps,
      bare: options.bare
    });
  } catch (error1) {
    error = error1;
    if (error instanceof SyntaxError) {
      error.print = function() {
        return printSyntaxError(error, file.path);
      };
    }
    throw error;
  }
  js = [options.maps ? transformed.js : transformed];
  if (options.maps) {
    fs.writeDir(path.dirname(mapPath));
    fs.writeFile(mapPath, transformed.v3SourceMap);
    file.mapDest = mapPath;
    js = js.concat([log.ln, "//# sourceMappingURL=", path.relative(path.dirname(file.dest), mapPath), log.ln]);
  }
  fs.writeDir(path.dirname(file.dest));
  fs.writeFile(file.dest, js.join(""));
  dest = lotus.File(file.dest, file.module);
  dest.lastModified = lastModified;
  return dest;
};
